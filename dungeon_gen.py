import random
from typing import Iterable

def seed(s=None):
    random.seed(a=s)

def cellular_automaton(w,h,wall_chance=42,iterations=3,spawn_walls=True):
    """Walls are True."""
    weighted_choices = [(True,wall_chance),(False,100-wall_chance)]
    choices = [x for x,p in weighted_choices for i in range(p)]
    g_map = {} #generator_map
    for x in range(w):
        for y in range(h):
            g_map[(x,y)] = random.choice(choices)

    def block_walls(pos,g_map):
        """How many walls are in a 3x3 block."""
        mx,my = pos
        result = 0
        for x in range(mx-1,mx+2):
            for y in range(my-1,my+2):
                try:
                    result += g_map[(x,y)]
                except KeyError:
                    result += 10
        return result

    for _ in range(iterations):
        new_map = g_map.copy()
        for pos in g_map:
            sur_walls = block_walls(pos,new_map)
            if  sur_walls < 5 :
                new_map[pos] = False
            elif spawn_walls and sur_walls == 0:
                new_map[pos] = random.choice(choices)
            else:
                new_map[pos] = True
        g_map = new_map
    return g_map

def neighbors(g_map,pos):
    """returns not wall neighbors of pos"""
    mx,my = pos
    result = set()
    for x in range(mx-1,mx+2):
        for y in range(my-1,my+2):
            if (x,y) in g_map and g_map[(x,y)] == False:
                result.add((x,y))
    return result

def neighbor_map(g_map):
    pos_neighbors = {}
    for pos in g_map:
        if g_map[pos] == False:
            pos_neighbors[pos] = neighbors(g_map,pos)
    return pos_neighbors

def check_map(g_map):
    pos_neighbors = neighbor_map(g_map)

    keys = [x for x in pos_neighbors.keys()]
    if len(keys) == 0:
        return False
    pos  = keys[0]
    while True:
        cp = pos_neighbors[pos].copy()
        for neighbor in pos_neighbors[pos]:
            cp.update(pos_neighbors[neighbor])
        if pos_neighbors[pos] == cp:
            break
        pos_neighbors[pos] = cp

    result = (pos_neighbors[pos] == set(pos_neighbors.keys()))
    return result

def checked_cellular_automaton(w,h,wall_chance = 42,iterations = 3,
                               spawn_walls=True):
    m = cellular_automaton(w,h,wall_chance,iterations,spawn_walls)
    i = 0
    while not check_map(m):
        m = cellular_automaton(w,h,wall_chance,iterations,spawn_walls)
        if i > 10000:
            raise ValueError("Map can't be generated")
        i += 1
    return m

def djikstra_map(wall_map,start_positions:Iterable):
    #assumes maps generated by checked_cellular_automaton
    pos_neighbors = neighbor_map(wall_map)
    d_map = {}
    INFINITY = 1000000000000000000
    for key in pos_neighbors:
        d_map[key] = INFINITY
    for pos in start_positions:
        if not pos in pos_neighbors:
            raise KeyError("start_positions are not free_tiles")
        d_map[pos] = 0
    changed = True
    while changed:
        changed = False
        for pos in d_map:
            for n_pos in pos_neighbors[pos]:
                if d_map[n_pos] + 1 < d_map[pos]:
                    d_map[pos] = d_map[n_pos] + 1
                    changed = True
    return d_map

#for testing import this module and execute the following function
def quick_display(wall_chance = 42,iterations = 3,seeed=None,
                  spawn_walls=True):
    seed(seeed)
    m = checked_cellular_automaton(20,15,wall_chance,
                                   iterations,spawn_walls)

    free_tiles = []
    for pos in m:
        if not m[pos]:
            free_tiles.append(pos)

    d_map = djikstra_map(m,free_tiles[::10000])

    for y in range(20):
        s = ""
        for x in range(20):
            if m[(x,y)]:
                s += "  #"
            else:
                c = str(d_map[(x,y)])
                if len(c) < 2:
                    c = "  " + c
                elif len(c) < 3:
                    c = " " + c
                s += c
        print(s)
    return m
